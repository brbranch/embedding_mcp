# 開発フロー仕様書

## 概要

TODOに記載されたタスクを効率的に実装するための開発フローを定義する。
複数のエージェントが役割分担し、品質を担保しながら開発を進める。

## 前提条件

### CI/ブランチ保護
- **CI**: このプロジェクトではCIは設定しない（ローカル開発主体）
- **ブランチ保護**: なし（PRマージ時のレビュー必須は運用ルールとして遵守）
- **テスト実行**: 各担当者がローカルで `go test ./...` を実行

### PRテンプレート
- 設計PR、実装PRそれぞれにチェックリストを含める（後述）

### レビュー基準
- 必須承認数: 1（レビュワーのLGTM）
- テスト実行責任: 実装者が実行し、結果をPRに記載

## エージェント一覧

| 役割 | 担当 | 主な責務 |
|------|------|----------|
| **設計者** | Claude Code Opus 4.5 | 実装計画の作成 |
| **レビュワー** | GitHub Copilot GPT-5.2-Codex | 設計・コードレビュー |
| **テスト実装者** | Claude Code Sonnet 4.5 | テストコードの作成（TDD） |
| **実装者** | Claude Code Sonnet 4.5 | 本実装コードの作成 |
| **テックリーダー** | Claude Code Opus 4.5 | エスカレーション調査・方針決定 |
| **E2E担当者** | Claude Code Sonnet 4.5 | 動作確認テストの実施 |
| **ドキュメント担当** | Claude Code Opus 4.5 | README更新 |

### 責務の明確化

- **設計者 vs テックリーダー**: 設計者は「計画立案」、テックリーダーは「問題発生時の調査・方針決定」を担当。同じモデルだが役割は分離。
- **テスト実装者 vs 実装者**: 同一モデルだが、TDD原則を守るため役割を分離。テスト実装者はテストのみ、実装者は実装のみを担当。
- **エスカレーション時の修正**: テックリーダーは調査・方針決定まで。実際の修正は実装者または設計者が担当。

## ブランチ・Worktree運用

### 命名規則
```
feature/phase{N}-task{M}
例: feature/phase1-task1, feature/phase2-task4
```

### Worktree作成
```bash
# 作成
git worktree add ../embedding_mcp-phase1-task1 -b feature/phase1-task1

# 作業完了後の削除
git worktree remove ../embedding_mcp-phase1-task1
git branch -d feature/phase1-task1
```

### 同期ルール
- 新規worktree作成前に `git fetch origin && git pull origin main` を実行
- 長期間のタスクでは週1回mainをリベース
- 複数タスク並行時は依存関係を確認（TODO.md の依存関係図を参照）

## 開発フロー詳細

### Step 1: Worktree作成

TODO内のタスク（Phase/タスク番号）ごとにworktreeを作成。

### Step 2: 設計者による実装計画作成

**担当**: 設計者（Claude Code Opus 4.5）

**成果物**: `docs/plans/phase{N}-task{M}.md`

**要件**:
1. 実装者（Sonnet 4.5）が不明点なく実装できるよう、L3（Function-level）まで詳細に記載
2. 以下を必ず含める:
   - 実装すべき関数/メソッドの一覧と概要
   - 関数シグネチャ（引数、戻り値、エラー）
   - 依存関係（他のパッケージ、外部ライブラリ）
   - ファイル構成
   - テストケース一覧（正常系、異常系、境界値）
   - エラーハンドリング方針
   - セキュリティ考慮事項
3. `requirements/` の仕様との整合性を確認

**アクション**: 設計完了後、PRを作成

**PRチェックリスト（設計PR）**:
```markdown
## 設計PRチェックリスト
- [ ] TODO.mdの該当タスクの要件を全て含んでいる
- [ ] requirements/ の仕様と整合している
- [ ] 関数シグネチャが明記されている
- [ ] テストケース一覧がある
- [ ] エラーハンドリング方針が定義されている
- [ ] セキュリティ考慮事項が記載されている
```

### Step 3: 設計レビュー

**担当**: レビュワー（GitHub Copilot GPT-5.2-Codex）

**観点**:
1. TODOの内容と実装計画に漏れがないか
2. `requirements/` の仕様と実装計画に改変がないか
3. 具体的な内容が記載されているか（曖昧な表現がないか）
4. テストすべき内容が網羅されているか
5. エラーハンドリングが定義されているか
6. セキュリティ要件が考慮されているか

**レビュー方法**:
- コード上の指摘: GitHubの行コメント
- 全体指摘: PRコメント

**レビュー対応**:
- 対応者はコメントに修正する/しないを返信
- 修正しない場合は理由を明記
- 再レビュー時、レビュワーはコメントをクローズするか再指摘

**完了条件**: LGTM → **設計PRをマージ**

### Step 4: テストコード作成

**担当**: テスト実装者（Claude Code Sonnet 4.5）

**前提**: Step 3で設計PRがマージ済み

**要件**:
1. 実装計画に基づいてテストコードを作成
2. テスト対象の関数スタブを作成（コンパイルは通る状態に）
3. テストは実行可能だがFail状態（Red）

**アクション**:
- テストコードをpush
- **新規PRを作成**（実装PR、**Draft状態**で作成）
- テスト実行結果を記載（`go test ./...` の出力）

**PRチェックリスト（実装PR）**:
```markdown
## 実装PRチェックリスト
- [ ] テストコードが実装計画と一致している
- [ ] テストが実行可能（コンパイルエラーなし）
- [ ] テスト実行結果を記載済み
- [ ] 本実装が完了（全テストパス）
- [ ] E2Eテスト完了
- [ ] README更新完了

## テストRed状態の理由（TDD）
- 現在のFail数: {N}件
- 期待するFail一覧:
  - TestXxx: 関数Xxxが未実装のため
  - TestYyy: 関数Yyyが未実装のため
- 解除条件: 本実装（Step 6）完了時に全テストがパスすること
```

### Step 5: テストレビュー

**担当**: レビュワー（GitHub Copilot GPT-5.2-Codex）

**観点**:
- 実装計画とテスト内容が一致しているか
- テストケースに漏れがないか
- テストRed状態の理由が明記されているか

**完了条件**: LGTM（PRは**Draft状態のまま**、実装待ち）

### Step 6: 本実装

**担当**: 実装者（Claude Code Sonnet 4.5）

**要件**:
1. 実装計画とテストコードに基づいて実装
2. 全てのテストが通ることがゴール
3. テストコードは原則修正しない
   - 修正が必要と判断した場合: エスカレーション
4. 他のテストケースが通らなくなった場合: エスカレーション

**アクション**:
- 実装コードをpush
- テスト実行結果を記載（全パスを確認）
- **PRをDraftからReady for Reviewに変更**

### Step 7: エスカレーション対応

**担当**: テックリーダー（Claude Code Opus 4.5）

**トリガー**:
- 実装者がテストコード修正が必要と判断した場合
- 他のテストケースが通らなくなった場合
- E2Eテストが通らない場合

**判断基準**:
- テスト修正が必要かどうかは「設計の意図」と「実装の現実」の乖離で判断
- 30分以上解決できない問題はエスカレーション対象

**対応フロー**:
1. 原因を調査
2. 調査結果を `docs/investigations/phase{N}-task{M}-{連番}.md` に記載
3. 修正方針を決定し、ドキュメントに追記
4. **実際の修正は以下が担当**:
   - テスト修正: テスト実装者
   - 実装修正: 実装者
   - 設計修正（大幅な変更）: 設計者（Step 2に戻る、新規PR）

**PRの扱い**:
- 軽微な修正: 現在のPRで継続
- 大幅な設計変更: 現在のPRをクローズし、修正計画から新規PRを作成

### Step 8: E2Eテスト

**担当**: E2E担当者（Claude Code Sonnet 4.5）

**要件**:
1. TODO記載の完了条件に基づいて動作確認
2. テスト結果をPRにコメント
3. 通らない場合: エスカレーション（Step 7へ）

**完了条件**: 全てのE2Eテストがパス

### Step 9: README更新

**担当**: ドキュメント担当（Claude Code Opus 4.5）

**前提**: E2Eテスト（Step 8）完了後

**要件**:
- 該当タスクの機能についてREADME.mdを更新
- 動作確認方法、設定方法を記載

### Step 10: 全体レビュー

**担当**: レビュワー（GitHub Copilot GPT-5.2-Codex）

**前提条件**:
- E2Eテスト完了
- README更新完了

**観点**:
1. 実装が仕様に準拠しているか
2. コード品質（可読性、保守性）
3. セキュリティ脆弱性がないか
4. ドキュメントが適切か

**対応**:
- 軽微な指摘（1-3件）: 実装者が修正
- 多数の指摘（4件以上）: テックリーダーが方針決定、実装者が修正

**完了条件**: LGTM

### Step 11: マージ＆リリース

**アクション**:
1. PRをマージ（Squash merge推奨）
2. featureブランチを削除
3. worktreeを削除
4. releaseタグを付与

**タグ命名規則**:
```
v{major}.{minor}.{patch}-phase{N}-task{M}
例: v0.1.0-phase1-task1
```

## PR運用ルール

### PR種別

| 種別 | 命名 | 内容 |
|------|------|------|
| 設計PR | `[設計] Phase{N} Task{M}: {概要}` | 実装計画のみ |
| 実装PR | `[実装] Phase{N} Task{M}: {概要}` | テスト + 実装 + README |

### 基本方針
- 設計と実装でPRを分ける
- 実装PRはテスト作成からマージまで同一PRで管理
- 最終レビュー（Step 10）でLGTMが出るまでマージしない

### コメントルール
- コード上の指摘: GitHubの行コメント
- 全体指摘: PRコメント

### 対応ルール
- 修正する場合: コメントに「修正しました」+ コミットハッシュを返信
- 修正しない場合: コメントに理由を明記して返信

### 再レビュールール
- 返信を確認し、コメントをResolveするか再指摘
- 全てResolveされたらLGTM

## 仕様変更時のフロー

requirements/ または TODO.md の変更が必要な場合:

1. テックリーダーが変更の影響範囲を調査
2. 変更内容を `docs/spec-changes/{日付}-{概要}.md` に記載
3. 設計者が影響を受ける実装計画を更新
4. 必要に応じて実装PRの方針を変更

## エラー処理フロー図

```
テスト失敗
  ├─> 実装修正で対応可能 ─> 実装者が修正 ─> 再テスト
  │
  └─> テストコード修正必要 ─> エスカレーション
        │
        └─> テックリーダー調査 ─> 調査ドキュメント作成
              │
              ├─> 軽微な修正 ─> テスト実装者が修正 ─> 現在のPRで継続
              │
              └─> 設計変更必要 ─> 現在のPRクローズ ─> Step 2から再開（新規PR）

E2E失敗
  └─> エスカレーション ─> テックリーダー調査
        │
        ├─> バグ ─> 調査ドキュメント作成 ─> 修正計画(Step 2から、新規PR)
        │
        └─> 設定ミス ─> 設定修正 ─> E2E再実行
```

## 成果物一覧

| 成果物 | 保存場所 | 担当 |
|--------|----------|------|
| 実装計画 | `docs/plans/phase{N}-task{M}.md` | 設計者 |
| 調査結果 | `docs/investigations/phase{N}-task{M}-{連番}.md` | テックリーダー |
| 仕様変更記録 | `docs/spec-changes/{日付}-{概要}.md` | テックリーダー |
| 進捗記録 | `docs/progress/phase{N}-task{M}.json` | スキル自動管理 |
| README | `README.md` | ドキュメント担当 |

## 進捗ファイル仕様

各タスクの進行状況を `docs/progress/phase{N}-task{M}.json` に記録する。

### フォーマット

```json
{
  "phase": 1,
  "task": 1,
  "taskName": "プロジェクト初期化とディレクトリ構造",
  "currentStep": 4,
  "status": "in_progress",
  "branch": "feature/phase1-task1",
  "worktree": "../embedding_mcp-phase1-task1",
  "designPR": {
    "number": 1,
    "url": "https://github.com/.../pull/1",
    "status": "merged"
  },
  "implPR": {
    "number": 2,
    "url": "https://github.com/.../pull/2",
    "status": "draft"
  },
  "startedAt": "2025-01-26T10:00:00Z",
  "history": [
    {"step": 1, "action": "worktree作成", "completedAt": "..."},
    {"step": 2, "action": "実装計画作成", "completedAt": "..."}
  ]
}
```

### 管理ルール

- **作成**: Step 1（Worktree作成）完了時に自動作成
- **更新**: 各Step完了時に自動更新
- **完了**: Step 11完了時に `status: "completed"` に変更
- **責任者**: `/dev-flow` スキルが自動管理（手動編集禁止）

### 再開時の動作

1. `status: "in_progress"` のファイルを検索
2. 複数ある場合は `startedAt` が最も新しいものを選択（ユーザー確認）
3. worktreeの存在確認（なければ再作成）
4. `currentStep` から作業を再開

## 成功基準

各タスクの完了は以下を満たすこと:
1. TODO記載の完了条件をパス
2. 全テスト（ユニット、E2E）がパス
3. 全体レビューでLGTM
4. READMEが更新済み
5. 設計PR・実装PRがマージ済み
6. releaseタグが付与済み
